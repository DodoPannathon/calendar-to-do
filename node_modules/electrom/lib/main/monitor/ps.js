"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.listProcesses = void 0;
const os_1 = require("os");
const path_1 = __importDefault(require("path"));
const child_process_1 = require("child_process");
function calculateLinuxCpuUsage() { }
function listProcesses(rootPid) {
    return new Promise((resolve, reject) => {
        const processMap = new Map();
        function addToMap(pid, ppid, cmd, load, mem) {
            const item = {
                cmd,
                pid,
                ppid,
                load,
                mem,
            };
            processMap.set(pid, item);
        }
        if (process.platform === 'win32') {
            getWindowsProcessList(rootPid)
                .then((processList) => {
                processList.forEach((item) => {
                    if (item) {
                        processMap.set(item.pid, {
                            cmd: item.cmd,
                            pid: item.pid,
                        });
                    }
                });
                resolve(processMap);
            })
                .catch((err) => {
                reject(err);
            });
        }
        else {
            // OS X & Linux
            (0, child_process_1.exec)('which ps', {}, (err, stdout, stderr) => {
                if (err || stderr) {
                    if (process.platform !== 'linux') {
                        reject(err || new Error(stderr.toString()));
                    }
                    else {
                        const cmd = JSON.stringify(path_1.default.join(__dirname, './ps.sh', require));
                        (0, child_process_1.exec)(cmd, {}, (err, stdout, stderr) => {
                            if (err || stderr) {
                                reject(err || new Error(stderr.toString()));
                            }
                            else {
                                parsePsOutput(stdout, addToMap);
                                calculateLinuxCpuUsage();
                            }
                        });
                    }
                }
                else {
                    const ps = stdout.toString().trim();
                    const args = '-ax -o pid=,ppid=,pcpu=,pmem=,command=';
                    // Set numeric locale to ensure '.' is used as the decimal separator
                    (0, child_process_1.exec)(`${ps} ${args}`, { maxBuffer: 1000 * 1024, env: { LANG: 'en_US.UTF-8', LC_NUMERIC: 'en_US.UTF-8' }, encoding: 'utf-8' }, (err, stdout, stderr) => {
                        // Silently ignoring the screen size is bogus error. See https://github.com/microsoft/vscode/issues/98590
                        if (err || (stderr && !stderr.includes('screen size is bogus'))) {
                            reject(err || new Error(stderr.toString()));
                        }
                        else {
                            parsePsOutput(stdout, addToMap);
                            if (process.platform === 'linux') {
                                calculateLinuxCpuUsage();
                            }
                            else {
                                resolve(processMap);
                            }
                        }
                    });
                }
            });
        }
    });
}
exports.listProcesses = listProcesses;
function parsePsOutput(stdout, addToTree) {
    const PID_CMD = /^\s*([0-9]+)\s+([0-9]+)\s+([0-9]+\.[0-9]+)\s+([0-9]+\.[0-9]+)\s+(.+)$/;
    const lines = stdout.toString().split('\n');
    for (const line of lines) {
        const matches = PID_CMD.exec(line.trim());
        if (matches && matches.length === 6) {
            addToTree(parseInt(matches[1]), parseInt(matches[2]), matches[5], parseFloat(matches[3]), parseFloat(matches[4]));
        }
    }
}
const getWindowsPsCodeWithChild = (rootPid) => `
$OutputEncoding = [console]::InputEncoding = [console]::OutputEncoding = New-Object System.Text.UTF8Encoding;
function Get-ChildProcesses ($ParentProcessId) {
    $filter = "parentprocessid = '$($ParentProcessId)'"
    Get-CIMInstance -ClassName Win32_Process -filter $filter | Foreach-Object {
        $_
        if ($_.ParentProcessId -ne $_.ProcessId) {
            Get-ChildProcesses $_.ProcessId
        }
    }
}
Get-ChildProcesses ${rootPid} | Select ProcessId, CommandLine | out-string -Width 1000
`;
function getWindowsProcessList(rootPid) {
    const PROCESS_REGEX = /(\d*)\s?(.*)?/;
    const outputFormatter = (output) => {
        const dataList = output.trim().split(os_1.EOL).slice(2);
        return dataList
            .map((item) => item.trim())
            .map((item) => item.match(PROCESS_REGEX))
            .map((item) => item && { pid: Number(item[1]), cmd: item[2] })
            .filter(Boolean);
    };
    const processListPromise = new Promise((resolve, reject) => {
        (0, child_process_1.exec)(`
      $OutputEncoding = [console]::InputEncoding = [console]::OutputEncoding = New-Object System.Text.UTF8Encoding;
      Get-CIMInstance -ClassName win32_process -filter "processid = ${rootPid}" | Select ProcessId, CommandLine | out-string -Width 1000`, { shell: 'powershell.exe' }, (error, stdout, stderr) => {
            if (error) {
                reject(error);
            }
            if (stderr) {
                console.error(stderr);
            }
            try {
                resolve(outputFormatter(stdout));
            }
            catch (parseError) {
                reject(parseError);
            }
        });
    });
    const childProcessListPromise = new Promise((resolve, reject) => {
        (0, child_process_1.exec)(getWindowsPsCodeWithChild(rootPid), { shell: 'powershell.exe' }, (error, stdout, stderr) => {
            if (error) {
                reject(error);
            }
            if (stderr) {
                console.error(stderr);
            }
            try {
                resolve(outputFormatter(stdout));
            }
            catch (parseError) {
                reject(parseError);
            }
        });
    });
    return Promise.all([processListPromise, childProcessListPromise]).then((arr) => arr.flat());
}
//# sourceMappingURL=ps.js.map